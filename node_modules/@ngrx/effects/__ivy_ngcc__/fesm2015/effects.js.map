{"version":3,"sources":["/home/max/angular/ngrx-data/node_modules/@ngrx/effects/fesm2015/effects.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwPC,oFAGC;;;;;;;;;;kCAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0ID,sGAGC;;;;;;;;qGAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoFD,sGAGC;;;;;;;;+FAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCD,sWAGC;;;;;;;;;;;;;;;;;;;;kCASA;;;;;;;;;;;;;;;;;;;;;;;;;;CAwBD,uTAGC;;;;;;;;;;;;;;;;;;kCAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6CD;;;;0BAGC","file":"effects.js","sourcesContent":["/**\n * @license NgRx 8.0.1\n * (c) 2015-2018 Brandon Roberts, Mike Ryan, Rob Wormald, Victor Savkin\n * License: MIT\n */\nimport { compose, ScannedActionsSubject, Store, StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { merge, Observable, Subject, defer, Notification } from 'rxjs';\nimport { catchError, ignoreElements, materialize, map, filter, groupBy, mergeMap, exhaustMap, dematerialize, concatMap, finalize } from 'rxjs/operators';\nimport { Injectable, Inject, ErrorHandler, InjectionToken, NgModule, Optional } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';\n/**\n * @template C, T, O, R\n * @param {?} source\n * @param {?=} config\n * @return {?}\n */\nfunction createEffect(source, config) {\n    /** @type {?} */\n    const effect = source();\n    // Right now both createEffect and @Effect decorator set default values.\n    // Ideally that should only be done in one place that aggregates that info,\n    // for example in mergeEffects().\n    /** @type {?} */\n    const value = Object.assign({ dispatch: true, resubscribeOnError: true }, config);\n    Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n        value,\n    });\n    return effect;\n}\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\nfunction getCreateEffectMetadata(instance) {\n    /** @type {?} */\n    const propertyNames = (/** @type {?} */ (Object.getOwnPropertyNames(instance)));\n    /** @type {?} */\n    const metadata = propertyNames\n        .filter((/**\n     * @param {?} propertyName\n     * @return {?}\n     */\n    propertyName => instance[propertyName] &&\n        instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)))\n        .map((/**\n     * @param {?} propertyName\n     * @return {?}\n     */\n    propertyName => {\n        /** @type {?} */\n        const metaData = ((/** @type {?} */ (instance[propertyName])))[CREATE_EFFECT_METADATA_KEY];\n        return Object.assign({ propertyName }, metaData);\n    }));\n    return metadata;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\nfunction getSourceForInstance(instance) {\n    return Object.getPrototypeOf(instance);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst METADATA_KEY = '__@ngrx/effects__';\n/**\n * @template T\n * @param {?=} __0\n * @return {?}\n */\nfunction Effect({ dispatch = true, resubscribeOnError = true, } = {}) {\n    return (/** @type {?} */ ((/**\n     * @template K\n     * @param {?} target\n     * @param {?} propertyName\n     * @return {?}\n     */\n    function (target, propertyName) {\n        // Right now both createEffect and @Effect decorator set default values.\n        // Ideally that should only be done in one place that aggregates that info,\n        // for example in mergeEffects().\n        /** @type {?} */\n        const metadata = {\n            propertyName,\n            dispatch,\n            resubscribeOnError,\n        };\n        setEffectMetadataEntries(target, [metadata]);\n    })));\n}\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\nfunction getEffectDecoratorMetadata(instance) {\n    /** @type {?} */\n    const effectsDecorators = compose(getEffectMetadataEntries, getSourceForInstance)(instance);\n    return effectsDecorators;\n}\n/**\n * @template T\n * @param {?} sourceProto\n * @param {?} entries\n * @return {?}\n */\nfunction setEffectMetadataEntries(sourceProto, entries) {\n    /** @type {?} */\n    const constructor = sourceProto.constructor;\n    /** @type {?} */\n    const meta = constructor.hasOwnProperty(METADATA_KEY)\n        ? ((/** @type {?} */ (constructor)))[METADATA_KEY]\n        : Object.defineProperty(constructor, METADATA_KEY, { value: [] })[METADATA_KEY];\n    Array.prototype.push.apply(meta, entries);\n}\n/**\n * @template T\n * @param {?} sourceProto\n * @return {?}\n */\nfunction getEffectMetadataEntries(sourceProto) {\n    return sourceProto.constructor.hasOwnProperty(METADATA_KEY)\n        ? ((/** @type {?} */ (sourceProto.constructor)))[METADATA_KEY]\n        : [];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\nfunction getEffectsMetadata(instance) {\n    /** @type {?} */\n    const metadata = {};\n    for (const { propertyName, dispatch, resubscribeOnError, } of getSourceMetadata(instance)) {\n        metadata[propertyName] = { dispatch, resubscribeOnError };\n    }\n    return metadata;\n}\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\nfunction getSourceMetadata(instance) {\n    /** @type {?} */\n    const effects = [\n        getEffectDecoratorMetadata,\n        getCreateEffectMetadata,\n    ];\n    return effects.reduce((/**\n     * @param {?} sources\n     * @param {?} source\n     * @return {?}\n     */\n    (sources, source) => sources.concat(source(instance))), []);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} sourceInstance\n * @param {?=} errorHandler\n * @return {?}\n */\nfunction mergeEffects(sourceInstance, errorHandler) {\n    /** @type {?} */\n    const sourceName = getSourceForInstance(sourceInstance).constructor.name;\n    /** @type {?} */\n    const observables$ = getSourceMetadata(sourceInstance).map((/**\n     * @param {?} __0\n     * @return {?}\n     */\n    ({ propertyName, dispatch, resubscribeOnError, }) => {\n        /** @type {?} */\n        const observable$ = typeof sourceInstance[propertyName] === 'function'\n            ? sourceInstance[propertyName]()\n            : sourceInstance[propertyName];\n        /** @type {?} */\n        const resubscribable$ = resubscribeOnError\n            ? observable$.pipe(catchError((/**\n             * @param {?} error\n             * @return {?}\n             */\n            error => {\n                if (errorHandler)\n                    errorHandler.handleError(error);\n                // Return observable that produces this particular effect\n                return observable$;\n            })))\n            : observable$;\n        if (dispatch === false) {\n            return resubscribable$.pipe(ignoreElements());\n        }\n        /** @type {?} */\n        const materialized$ = resubscribable$.pipe(materialize());\n        return materialized$.pipe(map((/**\n         * @param {?} notification\n         * @return {?}\n         */\n        (notification) => ({\n            effect: sourceInstance[propertyName],\n            notification,\n            propertyName,\n            sourceName,\n            sourceInstance,\n        }))));\n    }));\n    return merge(...observables$);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template V\n */\nclass Actions extends Observable {\n    /**\n     * @param {?=} source\n     */\n    constructor(source) {\n        super();\n        if (source) {\n            this.source = source;\n        }\n    }\n    /**\n     * @template R\n     * @param {?} operator\n     * @return {?}\n     */\n    lift(operator) {\n        /** @type {?} */\n        const observable = new Actions();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    }\n}\nActions.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nActions.ctorParameters = () => [\n    { type: Observable, decorators: [{ type: Inject, args: [ScannedActionsSubject,] }] }\n];\n/**\n * @param {...?} allowedTypes\n * @return {?}\n */\nfunction ofType(...allowedTypes) {\n    return filter((/**\n     * @param {?} action\n     * @return {?}\n     */\n    (action) => allowedTypes.some((/**\n     * @param {?} typeOrActionCreator\n     * @return {?}\n     */\n    typeOrActionCreator => {\n        if (typeof typeOrActionCreator === 'string') {\n            // Comparing the string to type\n            return typeOrActionCreator === action.type;\n        }\n        // We are filtering by ActionCreator\n        return typeOrActionCreator.type === action.type;\n    }))));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} output\n * @param {?} reporter\n * @return {?}\n */\nfunction reportInvalidActions(output, reporter) {\n    if (output.notification.kind === 'N') {\n        /** @type {?} */\n        const action = output.notification.value;\n        /** @type {?} */\n        const isInvalidAction = !isAction(action);\n        if (isInvalidAction) {\n            reporter.handleError(new Error(`Effect ${getEffectName(output)} dispatched an invalid action: ${stringify(action)}`));\n        }\n    }\n}\n/**\n * @param {?} action\n * @return {?}\n */\nfunction isAction(action) {\n    return (typeof action !== 'function' &&\n        action &&\n        action.type &&\n        typeof action.type === 'string');\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction getEffectName({ propertyName, sourceInstance, sourceName, }) {\n    /** @type {?} */\n    const isMethod = typeof sourceInstance[propertyName] === 'function';\n    return `\"${sourceName}.${propertyName}${isMethod ? '()' : ''}\"`;\n}\n/**\n * @param {?} action\n * @return {?}\n */\nfunction stringify(action) {\n    try {\n        return JSON.stringify(action);\n    }\n    catch (_a) {\n        return action;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst onIdentifyEffectsKey = 'ngrxOnIdentifyEffects';\n/** @type {?} */\nconst onRunEffectsKey = 'ngrxOnRunEffects';\n/** @type {?} */\nconst onInitEffects = 'ngrxOnInitEffects';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass EffectSources extends Subject {\n    /**\n     * @param {?} errorHandler\n     * @param {?} store\n     */\n    constructor(errorHandler, store) {\n        super();\n        this.errorHandler = errorHandler;\n        this.store = store;\n    }\n    /**\n     * @param {?} effectSourceInstance\n     * @return {?}\n     */\n    addEffects(effectSourceInstance) {\n        this.next(effectSourceInstance);\n        if (onInitEffects in effectSourceInstance &&\n            typeof effectSourceInstance[onInitEffects] === 'function') {\n            this.store.dispatch(effectSourceInstance[onInitEffects]());\n        }\n    }\n    /**\n     * \\@internal\n     * @return {?}\n     */\n    toActions() {\n        return this.pipe(groupBy(getSourceForInstance), mergeMap((/**\n         * @param {?} source$\n         * @return {?}\n         */\n        source$ => source$.pipe(groupBy(effectsInstance)))), mergeMap((/**\n         * @param {?} source$\n         * @return {?}\n         */\n        source$ => source$.pipe(exhaustMap(resolveEffectSource(this.errorHandler)), map((/**\n         * @param {?} output\n         * @return {?}\n         */\n        output => {\n            reportInvalidActions(output, this.errorHandler);\n            return output.notification;\n        })), filter((/**\n         * @param {?} notification\n         * @return {?}\n         */\n        (notification) => notification.kind === 'N')), dematerialize()))));\n    }\n}\nEffectSources.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nEffectSources.ctorParameters = () => [\n    { type: ErrorHandler },\n    { type: Store }\n];\n/**\n * @param {?} sourceInstance\n * @return {?}\n */\nfunction effectsInstance(sourceInstance) {\n    if (onIdentifyEffectsKey in sourceInstance &&\n        typeof sourceInstance[onIdentifyEffectsKey] === 'function') {\n        return sourceInstance[onIdentifyEffectsKey]();\n    }\n    return '';\n}\n/**\n * @param {?} errorHandler\n * @return {?}\n */\nfunction resolveEffectSource(errorHandler) {\n    return (/**\n     * @param {?} sourceInstance\n     * @return {?}\n     */\n    sourceInstance => {\n        /** @type {?} */\n        const mergedEffects$ = mergeEffects(sourceInstance, errorHandler);\n        if (isOnRunEffects(sourceInstance)) {\n            return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n        }\n        return mergedEffects$;\n    });\n}\n/**\n * @param {?} sourceInstance\n * @return {?}\n */\nfunction isOnRunEffects(sourceInstance) {\n    /** @type {?} */\n    const source = getSourceForInstance(sourceInstance);\n    return (onRunEffectsKey in source && typeof source[onRunEffectsKey] === 'function');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst IMMEDIATE_EFFECTS = new InjectionToken('ngrx/effects: Immediate Effects');\n/** @type {?} */\nconst ROOT_EFFECTS = new InjectionToken('ngrx/effects: Root Effects');\n/** @type {?} */\nconst FEATURE_EFFECTS = new InjectionToken('ngrx/effects: Feature Effects');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass EffectsRunner {\n    /**\n     * @param {?} effectSources\n     * @param {?} store\n     */\n    constructor(effectSources, store) {\n        this.effectSources = effectSources;\n        this.store = store;\n        this.effectsSubscription = null;\n    }\n    /**\n     * @return {?}\n     */\n    start() {\n        if (!this.effectsSubscription) {\n            this.effectsSubscription = this.effectSources\n                .toActions()\n                .subscribe(this.store);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this.effectsSubscription) {\n            this.effectsSubscription.unsubscribe();\n            this.effectsSubscription = null;\n        }\n    }\n}\nEffectsRunner.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nEffectsRunner.ctorParameters = () => [\n    { type: EffectSources },\n    { type: Store }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst ROOT_EFFECTS_INIT = '@ngrx/effects/init';\nclass EffectsRootModule {\n    /**\n     * @param {?} sources\n     * @param {?} runner\n     * @param {?} store\n     * @param {?} rootEffects\n     * @param {?} storeRootModule\n     * @param {?} storeFeatureModule\n     */\n    constructor(sources, runner, store, rootEffects, storeRootModule, storeFeatureModule) {\n        this.sources = sources;\n        runner.start();\n        rootEffects.forEach((/**\n         * @param {?} effectSourceInstance\n         * @return {?}\n         */\n        effectSourceInstance => sources.addEffects(effectSourceInstance)));\n        store.dispatch({ type: ROOT_EFFECTS_INIT });\n    }\n    /**\n     * @param {?} effectSourceInstance\n     * @return {?}\n     */\n    addEffects(effectSourceInstance) {\n        this.sources.addEffects(effectSourceInstance);\n    }\n}\nEffectsRootModule.decorators = [\n    { type: NgModule, args: [{},] }\n];\n/** @nocollapse */\nEffectsRootModule.ctorParameters = () => [\n    { type: EffectSources },\n    { type: EffectsRunner },\n    { type: Store },\n    { type: Array, decorators: [{ type: Inject, args: [ROOT_EFFECTS,] }] },\n    { type: StoreRootModule, decorators: [{ type: Optional }] },\n    { type: StoreFeatureModule, decorators: [{ type: Optional }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass EffectsFeatureModule {\n    /**\n     * @param {?} root\n     * @param {?} effectSourceGroups\n     * @param {?} storeRootModule\n     * @param {?} storeFeatureModule\n     */\n    constructor(root, effectSourceGroups, storeRootModule, storeFeatureModule) {\n        effectSourceGroups.forEach((/**\n         * @param {?} group\n         * @return {?}\n         */\n        group => group.forEach((/**\n         * @param {?} effectSourceInstance\n         * @return {?}\n         */\n        effectSourceInstance => root.addEffects(effectSourceInstance)))));\n    }\n}\nEffectsFeatureModule.decorators = [\n    { type: NgModule, args: [{},] }\n];\n/** @nocollapse */\nEffectsFeatureModule.ctorParameters = () => [\n    { type: EffectsRootModule },\n    { type: Array, decorators: [{ type: Inject, args: [FEATURE_EFFECTS,] }] },\n    { type: StoreRootModule, decorators: [{ type: Optional }] },\n    { type: StoreFeatureModule, decorators: [{ type: Optional }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass EffectsModule {\n    /**\n     * @param {?} featureEffects\n     * @return {?}\n     */\n    static forFeature(featureEffects) {\n        return {\n            ngModule: EffectsFeatureModule,\n            providers: [\n                featureEffects,\n                {\n                    provide: FEATURE_EFFECTS,\n                    multi: true,\n                    deps: featureEffects,\n                    useFactory: createSourceInstances,\n                },\n            ],\n        };\n    }\n    /**\n     * @param {?} rootEffects\n     * @return {?}\n     */\n    static forRoot(rootEffects) {\n        return {\n            ngModule: EffectsRootModule,\n            providers: [\n                EffectsRunner,\n                EffectSources,\n                Actions,\n                rootEffects,\n                {\n                    provide: ROOT_EFFECTS,\n                    deps: rootEffects,\n                    useFactory: createSourceInstances,\n                },\n            ],\n        };\n    }\n}\nEffectsModule.decorators = [\n    { type: NgModule, args: [{},] }\n];\n/**\n * @param {...?} instances\n * @return {?}\n */\nfunction createSourceInstances(...instances) {\n    return instances;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template Input, OutputAction, ErrorAction, CompleteAction, UnsubscribeAction\n * @param {?} configOrProject\n * @param {?=} errorFn\n * @return {?}\n */\nfunction act(\n/** Allow to take either config object or project/error functions */\nconfigOrProject, errorFn) {\n    const { project, error, complete, operator, unsubscribe } = typeof configOrProject === 'function'\n        ? {\n            project: configOrProject,\n            error: (/** @type {?} */ (errorFn)),\n            operator: concatMap,\n            complete: undefined,\n            unsubscribe: undefined,\n        }\n        : Object.assign({}, configOrProject, { operator: configOrProject.operator || concatMap });\n    return (/**\n     * @param {?} source\n     * @return {?}\n     */\n    source => defer((/**\n     * @return {?}\n     */\n    () => {\n        /** @type {?} */\n        const subject = new Subject();\n        return merge(source.pipe(operator((/**\n         * @param {?} input\n         * @param {?} index\n         * @return {?}\n         */\n        (input, index) => defer((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            let completed = false;\n            /** @type {?} */\n            let errored = false;\n            /** @type {?} */\n            let projectedCount = 0;\n            return project(input, index).pipe(materialize(), map((/**\n             * @param {?} notification\n             * @return {?}\n             */\n            (notification) => {\n                switch (notification.kind) {\n                    case 'E':\n                        errored = true;\n                        return new Notification((/** @type {?} */ (\n                        // TODO: remove any in RxJS 6.5\n                        'N')), error(notification.error, input));\n                    case 'C':\n                        completed = true;\n                        return complete\n                            ? new Notification((/** @type {?} */ (\n                            // TODO: remove any in RxJS 6.5\n                            'N')), complete(projectedCount, input))\n                            : undefined;\n                    default:\n                        ++projectedCount;\n                        return notification;\n                }\n            })), filter((/**\n             * @param {?} n\n             * @return {?}\n             */\n            (n) => n != null)), dematerialize(), finalize((/**\n             * @return {?}\n             */\n            () => {\n                if (!completed && !errored && unsubscribe) {\n                    subject.next(unsubscribe(projectedCount, input));\n                }\n            })));\n        }))))), subject);\n    })));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { EffectsFeatureModule as ɵngrx_modules_effects_effects_c, createSourceInstances as ɵngrx_modules_effects_effects_a, EffectsRootModule as ɵngrx_modules_effects_effects_b, EffectsRunner as ɵngrx_modules_effects_effects_f, FEATURE_EFFECTS as ɵngrx_modules_effects_effects_e, ROOT_EFFECTS as ɵngrx_modules_effects_effects_d, createEffect, Effect, getEffectsMetadata, mergeEffects, Actions, ofType, EffectsModule, EffectSources, ROOT_EFFECTS_INIT, act };\n"]}